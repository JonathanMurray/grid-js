
<script src="grid.js"></script>
<script src="text-grid.js"></script>

<script>
    "use strict";

    function init() {
        // Set from message sent from system
        let pid = null; 
        let programName = null;

        window.addEventListener("keydown", function(event) {
            if (event.code == "Tab") {
                event.preventDefault();
            }

            if (event.key == "s" && event.ctrlKey) {
                event.preventDefault();
            }
        });

        console.debug("Initializing program iframe ...");

        let nextSyscallSequenceNum = 1;
        let messageCallbacks = {};

        async function syscall(syscall, arg) {
            
            if (arg == undefined) {
                // Syscall implementations that try to destructure args crash otherwise
                arg = {};
            }

            let sequenceNum = nextSyscallSequenceNum ++;
            console.assert(!(sequenceNum in messageCallbacks), `message id ${sequenceNum} in ${JSON.stringify(messageCallbacks)}`);
            let callbacks = {};
            messageCallbacks[sequenceNum] = callbacks;

            console.debug("posting syscall...");
            console.assert(pid != null, "pid must have been assigned");
            parent.postMessage({syscall: {syscall, arg, pid, sequenceNum}}, "*");
            console.debug("posted syscall...");

            const asyncSyscallResult = new Promise((resolve, reject) => {
                callbacks.resolve = resolve;
                callbacks.reject = reject;
            });
            console.debug("created syscall promise...");
            
            try {
                const syscallResult =  await asyncSyscallResult;
                return syscallResult;
            } catch (e) {
                throw {name: e.name, message: e.message, cause: e};
            }
        }

        function writeln(line, streamId) {
            if (streamId == undefined) {
                // stdout by default
                streamId = 1;
            }
            return syscall("write", {line, streamId});
        }

        function readln() {
            return syscall("read", {streamId: 0});
        }

        async function onProgramCrashed(error) {

            console.warn("Program crashed: ", error);
            console.warn("Caused by: ", error.cause);

            await writeln(`[${pid}] crashed!`);

            const stackLines = error.stack.split('\n');

            const script = document.getElementById("program-script");
            let programFirstLineIndex;
            let programLastLineIndex;
            for (const [i, scriptLine] of script.text.split("\n").entries()) {
                if (programFirstLineIndex == undefined && scriptLine.includes("PROGRAM_START_MARKER")) {
                    programFirstLineIndex = i;
                } 
                if (scriptLine.includes("PROGRAM_END_MARKER")) {
                    programLastLineIndex = i;
                }
            }

            let hasStartedWritingStackLines = false;

            const regex = /\(<(.+)>:(.+):(.+)\)/;
            for (let stackLine of stackLines) {
                const match = stackLine.match(regex);
                if (match) {
                    const fileName = match[1];
                    if (fileName == "anonymous") {
                        const lineNumber = parseInt(match[2]);
                        if (lineNumber <= programLastLineIndex + 1) {
                            const colNumber = parseInt(match[3]);
                            const translatedStackLine = stackLine.replace(regex, `(${programName}:${lineNumber - programFirstLineIndex}:${colNumber})`);
                            await writeln(translatedStackLine);
                            hasStartedWritingStackLines = true;
                        }
                    }
                } else if (!hasStartedWritingStackLines) {
                    await writeln(stackLine);
                }
            }

            await syscall('exit');
        }

        function setupAndRunProgram(programCode, args) {
            const placeholder = document.getElementById("placeholder-script");
            const head = document.getElementsByTagName("head")[0];
            head.removeChild(placeholder);
            
            const script = document.createElement("script");
            script.setAttribute("id", "program-script");
            script.text = placeholder.text = placeholder.text.replace("// PROGRAM_PLACEHOLDER", programCode);;
            head.appendChild(script);
            
            runProgramAndCatchErrors(args);
        }

        window.addEventListener("mousedown", (event) => {
            parent.postMessage({iframeReceivedFocus: {pid: pid}}, "*");
        });

        window.addEventListener("message", message => {

            console.debug("Sandboxed program received message:", message.data);

            if ("startProcess" in message.data) {
                console.assert("programName" in message.data.startProcess);
                console.assert("code" in message.data.startProcess);
                console.assert("args" in message.data.startProcess);
                console.assert("pid" in message.data.startProcess);
                ({pid, programName} = message.data.startProcess);

                const {code, args} = message.data.startProcess;
                setupAndRunProgram(code, args);
            } else if ("syscallResult" in message.data) {
                const sequenceNum = message.data.syscallResult.sequenceNum;
                if ("success" in message.data.syscallResult) {
                    let result = message.data.syscallResult.success;
                    console.debug("Received syscall result in iframe: ", result);
                    messageCallbacks[sequenceNum].resolve(result);
                    delete messageCallbacks[sequenceNum]; // avoid leaking memory
                } else {
                    console.assert("error" in message.data.syscallResult);
                    let error = message.data.syscallResult.error;
                    console.debug("Received syscall error in iframe: ", error);
                    messageCallbacks[sequenceNum].reject(error);
                    delete messageCallbacks[sequenceNum]; // avoid leaking memory
                }
            } else {
                console.error("Unhandled message in program iframe", message.data);
            }
        });

        function log(args) {
            console.log(`[${pid}]`, args);
        }

        return {syscall, onProgramCrashed, writeln, readln, log};
    }

    // Public API available to application code
    const {syscall, onProgramCrashed, writeln, readln, log} = init();

</script>


<script id="placeholder-script">
    function runProgramAndCatchErrors(args) {
        try {
            // PROGRAM_START_MARKER
            // PROGRAM_PLACEHOLDER
            // PROGRAM_END_MARKER
            result = main(args);
            console.debug('program result', result);
            Promise.resolve(result)
                .then((value) => { console.debug("Program result: ", value); syscall("exit");})
                .catch((e) => { onProgramCrashed(e); });
        } catch (e) {
            onProgramCrashed(e);
        }
    }
</script>